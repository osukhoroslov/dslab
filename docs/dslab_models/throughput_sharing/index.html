<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Throughput sharing model"><title>dslab_models::throughput_sharing - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-081576b923113409.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="dslab_models" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0 (129f3b996 2024-06-10)" data-channel="1.79.0" data-search-js="search-bf21c90c8c1d92b1.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-e32f0c247825364d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../dslab_models/index.html">dslab_models</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">Module throughput_sharing</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In crate dslab_models</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../dslab_models/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">dslab_models</a>::<wbr><a class="mod" href="#">throughput_sharing</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/dslab_models/throughput_sharing/mod.rs.html#1-16">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="throughput-sharing-model"><a class="doc-anchor" href="#throughput-sharing-model">§</a>Throughput sharing model</h2>
<p>This model evaluates how some resource with limited throughput (e.g. network, storage or compute) is shared by several concurrent activities (e.g. data transfers or computations). Currently, only fair sharing is implemented, i.e. each activity gets an equal share of resource throughput computed as <code>throughput / num of activities</code>. </p>
<p>This model can be used to calculate completion times of such activities as network data transfers, storage read/write operations or compute tasks.</p>
<p>The dependence of resource total throughput on the number of concurrent activities, i.e. throughput degradation, can be modeled with a used-defined <em>resource throughput function</em>.</p>
<p>The dependence of effective activity throughput on its properties or the variability of throughput can be modeled with a used-defined <em>activity factor function</em>.</p>
<h3 id="slow-algorithm"><a class="doc-anchor" href="#slow-algorithm">§</a>Slow algorithm</h3>
<p>This is a simple algorithm which explicitly recalculates all activities’ completion times on every <code>insert</code> and <code>pop</code> call. <code>BinaryHeap</code> is used as a storage for activities, and they are sorted by their remaining volume.</p>
<p>Recalculation consists of 3 steps:</p>
<ol>
<li>Update <code>throughput_per_item</code> using the resource throughput function.</li>
<li>Compute <code>processed_volume</code> - amount of work done by each activity since the last recalculation time.</li>
<li>For each activity update its <code>remaining_volume</code> by subtracting the <code>processed_volume</code> and push the updated entry to the new binary heap.</li>
<li>Update the last recalculation time.</li>
</ol>
<h3 id="fast-algorithm"><a class="doc-anchor" href="#fast-algorithm">§</a>Fast algorithm</h3>
<p>Algorithm can be optimized based on the fairness guarantee. If activities stored in the heap are ordered by their remaining volume, then reorderings in the heap are not possible because each activity gets equal throughput ratio at each time interval. That is why a full scan of the heap on each step is ineffective and can be avoided by using a simple metric described below.</p>
<p>Total work per activity or simply <em>total work (TW)</em> at time moment <em>t</em> is calculated as a volume processed by the resource <em>per activity</em> since the resource started till <em>t</em>. When there is a single activity using the resource, the total work is being increased by the full resource throughput for every time unit. When there are <em>N</em> concurrent activities, the total work is being increased by the full throughput divided by <em>N</em>.</p>
<p>For every activity in the system the following equation is satisfied: <em>TW(start_time) + volume = TW(end_time)</em>. So, when a new activity is placed into the model, it calculates <em>TW(end_time)</em> as current <em>TW</em> + activity volume. The computed value, called activity <em>finish work</em>, is inserted in the heap. Activities are popped from the heap in the ascending order of their finish work.</p>
<p>The total work is updated efficiently too: instead of adding some volume every time unit, it is incremented only when some activity is inserted or popped from the model. The increment value is calculated as multiplication of time passed since the last update and throughput per activity during this period.</p>
<p>Note that the total work is always increasing. To avoid the overflow, each time the total work is above <em>1E+12</em> it is reset to 0 and the finish work of each activity is reduced by the old value of total work. This is correct because the activities’ order does not change, and the finish times are preserved too, since they are calculated based on the difference between finish work and total work, which also does not change.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ConstantFactorFn.html" title="struct dslab_models::throughput_sharing::ConstantFactorFn">ConstantFactorFn</a></div><div class="desc docblock-short">Activity factor function with constant factor value.</div></li><li><div class="item-name"><a class="struct" href="struct.EmpiricalFactorFn.html" title="struct dslab_models::throughput_sharing::EmpiricalFactorFn">EmpiricalFactorFn</a></div><div class="desc docblock-short">Activity factor function which generates random factor from the specified weighted points distribution.</div></li><li><div class="item-name"><a class="struct" href="struct.FairThroughputSharingModel.html" title="struct dslab_models::throughput_sharing::FairThroughputSharingModel">FairThroughputSharingModel</a></div><div class="desc docblock-short">Fast implementation of fair throughput sharing model.</div></li><li><div class="item-name"><a class="struct" href="struct.RandomizedFactorFn.html" title="struct dslab_models::throughput_sharing::RandomizedFactorFn">RandomizedFactorFn</a></div><div class="desc docblock-short">Activity factor function which generates random factor values from the specified distribution.</div></li><li><div class="item-name"><a class="struct" href="struct.SlowFairThroughputSharingModel.html" title="struct dslab_models::throughput_sharing::SlowFairThroughputSharingModel">SlowFairThroughputSharingModel</a></div><div class="desc docblock-short">Slow implementation of fair throughput sharing model, which recalculates all event times at each activity creation
and completion.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ActivityFactorFn.html" title="trait dslab_models::throughput_sharing::ActivityFactorFn">ActivityFactorFn</a></div><div class="desc docblock-short">Provides the function that computes the throughput factor per activity.</div></li><li><div class="item-name"><a class="trait" href="trait.ThroughputSharingModel.html" title="trait dslab_models::throughput_sharing::ThroughputSharingModel">ThroughputSharingModel</a></div><div class="desc docblock-short">Trait for throughput sharing model.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.make_constant_throughput_fn.html" title="fn dslab_models::throughput_sharing::make_constant_throughput_fn">make_constant_throughput_fn</a></div><div class="desc docblock-short">Creates resource throughput function which always returns the given value.</div></li><li><div class="item-name"><a class="fn" href="fn.make_uniform_factor_fn.html" title="fn dslab_models::throughput_sharing::make_uniform_factor_fn">make_uniform_factor_fn</a></div><div class="desc docblock-short">Creates randomized activity factor function with uniform distribution in <code>[low, high]</code> range.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ResourceThroughputFn.html" title="type dslab_models::throughput_sharing::ResourceThroughputFn">ResourceThroughputFn</a></div><div class="desc docblock-short">Function that computes the total resource throughput based on the number of concurrent activities.</div></li></ul></section></div></main></body></html>